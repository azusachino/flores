---
title: 数据结构与算法之美
created: 2023-01-05 08:00:00
modified: 2023-04-02 13:42:01
tags: [Column, Tech, Algorithm]
author: 王争
read: 9
total: 50
---

## 重点掌握

- 数组、链表、栈、队列、散列表、二叉树、堆、跳表、图、Trie
- 递归、排序、二分查找、搜索、哈希算法、贪心算法、分治算法、回溯算法、动态规划、字符串匹配算法

## 复杂度分析

### 时间复杂度

1. **只关注循环执行次数最多的一段代码**
2. **加法法则：总复杂度等于量级最大的那段代码的复杂度**
3. **乘法法则：嵌套代码的复杂度等于嵌套内外代码复杂度的乘积**

#### 常见时间复杂度

- 常量 O(1)
- 对数 O(logn)
- 线性 O(n)
- 线性对数 O(nlogn)
- 平方 O(n^2)
- 指数 O(2^n)
- 阶乘 O(n!)

### 空间复杂度

**算法的存储空间与数据规模之间的增长关系**。

```java
// O(n)
void print(int n) {
    int[] a = new int[n];
}
```

### 分析手法

- **最好情况时间复杂度**（best case time complexity）
- **最坏情况时间复杂度**（worst case time complexity）
- **平均情况时间复杂度**（average case time complexity）
- **均摊时间复杂度**（amortized time complexity）

## 数据结构与算法

### 数组

为何数组坐标从 0 开始？ 下标的更准确说法应该是: **偏移位数**

```c
int a[];
// 基址 + 偏移量
a[k]_address = base_address + k * type_size;
```

#### BinarySearch

```py
def binary_search(arr, t) -> int:
    if not arr:
        return -1
    l, r = 0, len(arr)
    while l <= r:
        m = l + (r - l) // 2
        if arr[m] > t:
            r = m
        elif arr[m] < t:
            l = m + 1
        else:
            return m
    return l
```

### LinkedList

1. 理解指针或引用的具体含义
2. 警惕指针丢失和内存泄漏
3. 利用哨兵减少实现难度【dummy head 节点】
4. 重点留意边界处理
5. 举例画图，辅助思考
6. 多写多练

```py
class ListNode:
    def __init__(self, val=0, next=None):
        self.val = val
        self.next = next
```

#### 单链表反转

```py
class Solution:
    def reverseList(self, head: ListNode) -> ListNode:
        prev = None
        cur = head
        while cur:
            nxt = cur.next
            cur.next = prev
            prev = cur
            cur = nxt
        return prev
```

#### 链表中环的检测

```py
def hasCycle(self, head: ListNode) -> bool:
    slow, fast = head, head
    while fast and fast.next:
        slow = slow.next
        fast = fast.next.next
        if slow == fast:
            return True
    return False
```

#### 两个有序的链表合并

```py
def mergeTwoLists(self, list1: ListNode, list2: ListNode) -> ListNode:
    dummy = cur = ListNode(-1)
    while list1 and list2:
        if list1.val >= list2.val:
            cur.next = list2
            list2 = list2.next
        else:
            cur.next = list1
            list1 = list1.next
        cur = cur.next
    cur.next = list1 or list2

    return dummy.next
```

#### 寻找中间节点

```py
def middleNode(self, head: Optional[ListNode]) -> Optional[ListNode]:
    slow, fast = head, head
    while fast and fast.next:
        slow = slow.next
        fast = fast.next.next
    # 偶数返回右侧
    if fast and fast.next:
        return slow.next
    return slow
```

### Stack

```py
class MyStack:
    def __init__(self, cap):
        self.data = [0] * cap
        self.cap = cap
        self.index = -1

    def push(self, val) -> bool:
        if self.index >= self.cap - 1:
            return False
        self.index += 1
        self.data[self.index] = val
        return True

    def pop(self) -> Optional[int]:
        if self.index < 0:
            return None
        ret = self.data[self.index]
        self.index -= 1
        return ret

    def empty(self) -> bool:
        return self.index < 0
```

### Queue

```py
class CircularQueue:
    def __init__(self, cap):
        self.data = [0] * cap
        self.cap = cap
        self.head = 0
        self.tail = 0

    def enqueue(self, val) -> bool:
        if self.full():
            return False
        self.data[self.tail] = val
        self.tail = (self.tail + 1) % self.cap
        return True

    def dequeue(self) -> Optional[int]:
        if self.empty():
            return None
        ret = self.data[self.head]
        self.head = (self.head + 1) % self.cap
        return ret

    def full(self) -> bool:
        return (self.tail + 1) % self.cap == self.head

    def empty(self) -> bool:
        return self.head == self.tail
```

## 概览

![[../../images/data-structure-and-algorithm.jpg]]

## References

- [数据结构与算法之美](https://time.geekbang.org/column/intro/100017301)
- 《算法导论》
