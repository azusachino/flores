---
doc_type: weread-highlights-reviews
bookId: "27371406"
author: 周志明
cover: https://weread-1258476243.file.myqcloud.com/weread/cover/14/YueWen_27371406/t7_YueWen_27371406.jpg
reviewCount: 0
noteCount: 22
isbn: 9787111641247
category: 计算机-编程设计
tags:
  - Book
  - Weread
created: 2022-12-05 16:40:00
modified: 2022-12-05 16:40:00
---

## 深入理解Java虚拟机：JVM高级特性与最佳实践（第3版）

![27371406](https://weread-1258476243.file.myqcloud.com/weread/cover/14/YueWen_27371406/t7_YueWen_27371406.jpg)
- 书名: 深入理解Java虚拟机：JVM高级特性与最佳实践（第3版）
- 作者: 周志明
- 简介: 本书一共分为五个部分：走近Java、自动内存管理、虚拟机执行子系统、程序编译与代码优化、高效并发。各个部分之间基本上是互相独立的，没有必然的前后依赖关系，读者可以从任何一个感兴趣的专题开始阅读，但是每个部分各个章节间则有先后顺序。
- 出版时间: 2019-11-01 00:00:00
- ISBN: 9787111641247
- 分类: 计算机-编程设计
- 出版社: 机械工业出版社

## 高亮划线

### 2.2 运行时数据区域


> [!quote] ⏱ 2020-11-13 23:40:55
> 它是程序控制流的指示器，分支、循环、跳转、异常处理、线程恢复等基础功能
 


> [!quote] ⏱ 2020-11-13 23:41:27
> Java虚拟机都会同步创建一个栈帧￼（Stack Frame）用于存储局部变量表、操作数栈、动态连接、方法出口等信息
 


> [!quote] ⏱ 2020-11-13 23:45:03
> 用于存储已被虚拟机加载的类型信息、常量、静态变量、即时编译器编译后的代码缓存等数据。
 


### 2.3 HotSpot虚拟机对象探秘


> [!quote] ⏱ 2020-11-15 16:15:47
> 指针碰撞
 


> [!quote] ⏱ 2020-11-15 16:15:51
> 空闲列表
 


> [!quote] ⏱ 2020-11-15 16:21:28
> 每个线程在Java堆中预先分配一小块内存，称为本地线程分配缓冲
 


> [!quote] ⏱ 2020-11-09 08:17:35
> 哈希码（HashCode）、GC分代年龄、锁状态标志、线程持有的锁、偏向线程ID、偏向时间戳
 


> [!quote] ⏱ 2020-11-09 12:55:59
> 使用句柄访问的话，Java堆中将可能会划分出一块内存来作为句柄池，reference中存储的就是对象的句柄地址，而句柄中包含了对象实例数据与类型数据各自具体的地址信息
 


### 2.4 实战：OutOfMemoryError异常


> [!quote] ⏱ 2020-11-09 13:02:05
> 如果线程请求的栈深度大于虚拟机所允许的最大深度，将抛出StackOverflowError异常。
 


> [!quote] ⏱ 2020-11-09 13:02:10
> 如果虚拟机的栈内存允许动态扩展，当扩展栈容量无法申请到足够的内存时，将抛出OutOfMemoryError异常。
 


### 3.2 对象已死？


> [!quote] ⏱ 2020-11-10 13:33:34
> 在虚拟机栈（栈帧中的本地变量表）中引用的对象，譬如各个线程被调用的方法堆栈中使用到的参数、局部变量、临时变量等。
 


> [!quote] ⏱ 2020-11-10 13:33:39
> 在方法区中类静态属性引用的对象，譬如Java类的引用类型静态变量。
 


> [!quote] ⏱ 2020-11-10 13:34:10
> 在方法区中常量引用的对象，譬如字符串常量池（String Table）里的引用。·在本地方法栈中JNI（即通常所说的Native方法）引用的对象。·Java虚拟机内部的引用，如基本数据类型对应的Class对象，一些常驻的异常对象（比如NullPointExcepiton、OutOfMemoryError）等，还有系统类加载器。
 


> [!quote] ⏱ 2020-11-10 13:33:58
> 所有被同步锁（synchronized关键字）持有的对象。·反映Java虚拟机内部情况的JMXBean、JVMTI中注册的回调、本地代码缓存等。
 


> [!quote] ⏱ 2020-11-12 10:32:54
> 无论任何情况下，只要强引用关系还存在，垃圾收集器就永远不会回收掉被引用的对象。
 


> [!quote] ⏱ 2020-11-12 10:33:06
> 只被软引用关联着的对象，在系统将要发生内存溢出异常前，会把这些对象列进回收范围之中进行第二次回收，如果这次回收还没有足够的内存，才会抛出内存溢出异常。
 


> [!quote] ⏱ 2020-11-12 10:33:14
> 当垃圾收集器开始工作，无论当前内存是否足够，都会回收掉只被弱引用关联的对象。
 


> [!quote] ⏱ 2020-11-12 10:33:23
> 为一个对象设置虚引用关联的唯一目的只是为了能在这个对象被收集器回收时收到一个系统通知。
 


### 12.3 Java内存模型


> [!quote] ⏱ 2020-11-12 12:52:14
> Java内存模型规定了所有的变量都存储在主内存（Main Memory）中
 


> [!quote] ⏱ 2020-11-12 12:52:27
> 线程的工作内存中保存了被该线程使用的变量的主内存副本[插图]，线程对变量的所有操作（读取、赋值等）都必须在工作内存中进行，而不能直接读写主内存中的数据[插图]。
 


> [!quote] ⏱ 2020-11-12 12:59:40
> 保证此变量对所有线程的可见性
 


> [!quote] ⏱ 2020-11-12 12:59:22
> volatile变量的第二个语义是禁止指令重排序优化，普通的变量仅会保证在该方法的执行过程中所有依赖赋值结果的地方都能获取到正确的结果，而不能保证变量赋值操作的顺序与程序代码中的执行顺序一致。
 



## 读书笔记


## 本书评论

